/** https://bjornjohansen.no/encrypt-file-using-ssh-key **
1. Data can be encryped using public SSH key, and then send to anywhere
   safely even over an insecure internet connection. It can be only
   decrypted successfully by who has the private SSH key.
2. The length of the data can be encrypted using asymmetric RSA public
   key is limited. For this reason, we usually generate a 256-bit (32-
   byte) key to use for symmetric AES encryption and then encrypt and
   decrypt that symmetric AES key with the asymmetric RSA keys. This is
   how encrypted connections usually work.
3. For example, generate a one-time use symmetric key (32-byte):
       $ openssl rand -out secret.key 32
   Then encrypt the file using the generated symmetric key:
       $ openssl aes-256-cbc -a -in input.txt -out encrypted.txt -pass file:secret.key
   Encrypt the symmetric key using the recipient's public SSH key:
       $ openssl rsautl -encrypt -oaep -pubin -inkey <(ssh-keygen -e -f recipient-key.pub -m PKCS8) -in secret.key -out secret.key.enc
       $ rm secret.key
   Decrypt the symmetric key first:
       $ openssl rsautl -decrypt -oaep -inkey ~/.ssh/id_rsa -in secret.key.enc -out secret.key
   Decrypt the file:
       $ openssl aes-256-cbc -d -a -in encrypted.txt -out output.txt -pass file:secret.key
       $ rm secret.key
4. SSH remote device without enter password
       $ ssh-kegen -t rsa
       $ chmod 600 .ssh/id_rsa
       $ scp .ssh/id_rsa.pub user@remote:/path/
       $ ssh user@remote  # with password
       $ cat id_rsa.pub >> .ssh/authorized_key
       $ ssh user@remote  # without password
       $ vi /etc/ssh/sshd_config
       $ PasswordAuthentication no   # disable password authentication
       $ Port 4444 # 22              # change the default SSH port
       $ service ssh restart         # restart the SSH service
       $ vi ~/.ssh/config
       $ Host *
       $     ServerAliveInterval 120 # send a packet to server every 2-minute to keep connections alive
       $ Host remotehost
       $     HostName example.com
       $     Port 4444
       $     User username
       $ ssh -p 4444 user@remote
       $ ssh remotehost
5. When a client connects to the server, wishing to use SSH key authentication,
   it will inform the server of this intent and will tell the server which
   public key to use. The server then check its authorized_keys file for the
   public key, generate a random string and encrypts it using the public key.
   This encrypted message can only be decrypted with the associated private key.
   The server will send this encrypted message to the client to test whether
   they actually have the associated private key.
   Upon receipt of this message, the client will decrypt it using the private
   key and combine the random string that is revealed with a previously negotiated
   session ID. It then generates an MD5 hash of this value and transmits it
   back to the server. The server already had the original message and the
   session ID, so it can compare an MD5 hash generated by those values and
   determine that the client must have the private key.
--- OpenSSL ---
   https://wiki.openssl.org/index.php/Main_Page
   https://wiki.openssl.org/index.php/Libcrypto_API
   https://wiki.openssl.org/index.php/Category:Crypto_API
1. libcrypto generic
   For most uses, users should use the high level interface that is provided for
   performing cryptographic operations. This is known as the EVP interface (short
   for Envelope). This interface provides a suite of functions for performing
   encryption/decryption (both symmetric and asymmetric), signing/verifying, as
   well as generating hashes and MAC codes, across the full range of OpenSSL
   supported algorithms and modes. Working with the hith level interfaces means
   that a lot of the complexity of performing cryptographic operations is hidden
   from view.
2. https://www.openssl.org/docs/man1.1.1/man3/EVP_EncryptInit.html

EVP_CIPHER_CTX* EVP_CIPHER_CTX_new();
            int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX* ctx);
           void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX* ctx);

// setup cipher context for encryption with cipher type from engine impl.
// type is normally supplied by a function such as EVP_aes_256_cbc()
// if impl is NULL then the default implementation is used
// key is the symmetric key to use and iv is the IV to use if necessary
// the acutal number of bytes used for the key and IV depends on the cipher
// IV - initialization vector
int EVP_EncryptInit_ex(EVP_CIPHER_CTX* ctx, const EVP_CIPHER* type, ENGINE* impl, const l_byte* key, const l_byte* iv);

// encrypt in_len bytes from the buffer in and writes the encrypted version to out
// this function can be called multiple times to encrypt successive blocks of data
// the amount of data written depends on the blocks alignment of the encrypted data
// as a result the amount of data written may be anything from 0-byte to (in_len + cipher_block_size - 1)
// so out should contain sufficent room, and the actual number of bytes written is placed in out_len
int EVP_EncryptUpdate(EVP_CIPHER_CTX* ctx, l_byte* out, int* out_len, const l_byte* in, int in_len);

// if padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts the "final" data
// that is any data that remains in a prtial block. it uses standard block padding (aka PKCS padding).
// the encrypted final data is written to out which should have sufficient space for one cipher block.
// the number of bytes written is placed in out_len. after this function is called the encryption
// operation is finished and no further calls to EVP_EncryptUpdate() should be made.
// if padding is diabled then EVP_EncryptFinal_ex() will not encrypt any more data and it will return
// an error if any data remains in a prtical block. that is if the total data length is not a multiple
// of the block size.
int EVP_EncryptFinal_ex(EVP_CIPHER_CTX* ctx, l_byte* out, int* out_len);

3. https://en.wikipedia.org/wiki/Initialization_vector
In cipher-block chaining mode (CBC mode), the IV must, in addtion to being unique, be unpredictable
at encryption time. In particular, re-using the last ciphertext block of a message as the IV for
the next message is insecure. if an attacker knows the IV before he specifies the next plaintext,
he can check his guess about plaintext of some block that was encrypted with the same key before.
This known as the TLS CBC IV attack, also called the BEAST attack.

Initialization Vector for CBC mode
- IV should be unique and unpredicatable
- IV itself can be make public

4. https://stackoverflow.com/questions/28247821/openssl-vs-gpg-for-encrypting-off-site-backups
   http://tombuntu.com/index.php/2007/12/12/simple-file-encryption-with-openssl/
   https://stackoverflow.com/questions/16056135/how-to-use-openssl-to-encrypt-decrypt-files
   https://crypto.stackexchange.com/questions/3091/generating-a-strong-unique-initialization-vector
   https://stackoverflow.com/questions/1785555/how-should-i-generate-an-initialization-vector
   https://crypto.stackexchange.com/questions/732/why-use-an-initialization-vector-iv
   https://stackoverflow.com/questions/8041451/good-aes-initialization-vector-practice
   https://stackoverflow.com/questions/4608489/how-to-pick-an-appropriate-iv-initialization-vector-for-aes-ctr-nopadding
   https://stackoverflow.com/questions/65879/should-i-use-an-initialization-vector-iv-along-with-my-encryption
   https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
   https://stackoverflow.com/questions/7364819/how-do-i-get-the-initialization-vector-iv-from-openssl-encrypted-data
   https://stackoverflow.com/questions/16056135/how-to-use-openssl-to-encrypt-decrypt-files

5. https://cpp.libhunt.com/
**/
#include <openssl/evp.h>
class l_cipher {
  enum {TEXT_PIECE_LEN = 1024};
  EVP_CIPHER_CTX* ctx;
public:
  l_cipher() {
    ctx = EVP_CIPHER_CTX_new();
  }
  ~l_cipher() {
    if (ctx != 0) {
      EVP_CIPHER_CTX_free(ctx);
      ctx = 0;
    }
  }
  l_string encrypt(l_strn plaintext, const l_byte* key) {
    l_byte enc_key[40] = {0};
    l_byte env_iv[40] = {0};
    int key_len = 0;
    int iv_len = 0;

    l_byte* indata = 0;
    int inlen = 0;
    l_int i = 0;
    l_byte outbuf[TEXT_PIECE_LEN + EVP_MAX_BLOCK_LENGTH];
    int outlen = 0;

    l_string enctext;

    /* it can be to set all parameters to NULL except type in an initial call
    supply the remianing paramters in subsequent calls, all of which have type
    set to NULL. */
    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, NULL, NULL) == 0) {
      return l_string();
    }

    key_len = EVP_CIPHER_CTX_key_length(ctx);
    if (key_len != 32 || key.p == 0 || key.n != 32) {
      l_loge_2(LNUL, "encrypt key length %d %d", ld(key_len), ld(key.n));
      return l_string();
    }

    iv_len = EVP_CIPHER_CTX_iv_length(ctx);
    if (iv_len != 16) {
      l_loge_1(LNUL, "encrypt iv length %d", ld(iv_len));
      return l_string();
    }

    l_copy_n(enc_key, key.p, key.n);

    /* iv should be unique and unpredictable for CBC mode */
    { l_ulong ms = l_mono_time_ms();
      enc_iv[0x00] = env_iv[0x0e] = (l_byte)(ms & 0xff);
      enc_iv[0x01] = env_iv[0x0f] = (l_byte)((ms >>= 8) & 0xff);
      enc_iv[0x02] = env_iv[0x0c] = (l_byte)((ms >>= 8) & 0xff);
      env_iv[0x03] = env_ic[0x0d] = (l_byte)((ms >>= 8) & 0xff);
      env_iv[0x04] = env_ic[0x0a] = (l_byte)((ms >>= 8) & 0xff);
      env_iv[0x05] = env_ic[0x0b] = (l_byte)((ms >>= 8) & 0xff);
      env_iv[0x06] = env_ic[0x08] = (l_byte)((ms >>= 8) & 0xff);
      env_iv[0x07] = env_ic[0x09] = (l_byte)((ms >>= 8) & 0xff);
    }

    if (EVP_EncryptInit_ex(ctx, nullptr, nullptr, enc_key, enc_iv) == 0) {
      return l_string();
    }

    enctext.append(env_iv, iv_len);

    for (; ;) {
      if (i + TEXT_PIECE_LEN <= plaintext.n) {
        if (EVP_EncryptUpdate(ctx, outbuf, &outlen, plaintext + i, TEXT_PIECE_LEN) == 0) {
          return l_string();
        }
        enctext.append(outbuf, outlen);
        i += TEXT_PIECE_LEN;
        continue;
      }
      inlen = plaintext.n - i;
      if (inlen > 0) {
        if (EVP_EncryptUpdate(ctx, outbuf, &outlen, plaintext + i, inlen) == 0) {
          return l_string();
        }
        enctext.append(outbuf, outlen);
      }
      break;
    }

    if (EVP_EncryptFinal_ex(ctx, outbuf, &outlen) == 0) {
      return l_string();
    }
    enctext.append(outbuf, outlen);

    return enctext;
  }
}
